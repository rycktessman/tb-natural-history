c_tx=qunif(c_tx, min=params_lb[["c_tx"]], max=params_ub[["c_tx"]]),
a_m=qunif(a_m, min=params_lb[["a_m"]], max=params_ub[["a_m"]]),
m_tb=qunif(m_tb, min=params_lb[["m_tb"]], max=params_ub[["m_tb"]]),
a_tx=qunif(a_tx, min=params_lb[["a_tx"]], max=params_ub[["a_tx"]])
)
#remove samples when probabilities sum to > 1
priors <- priors %>% mutate(a_p_s=a_p_m, a_r_s=a_r_m, #dependencies
m_ac=params_fixed_hist$m_ac, #use hist bc its larger
p_c=params_fixed_hist$p_c) #prev and hist are same
priors <- priors %>%
mutate(flag1=1*((p_m + p_s + m_ac + c_sp) > 1),
flag2=1*((r_m + a_p_s*p_s + m_ac) > 1),
flag3=1*((r_s + a_p_m*p_m + m_tb + m_ac + c_tx) > 1),
flag4=1*((a_r_s*r_s + a_r_m*r_m + a_m*m_tb + m_ac + a_tx*c_tx) > 1),
flag5=1*((p_c + m_ac) > 1)
)
priors <- priors %>% select(-c(a_p_s, a_r_s, m_ac, p_c)) #remove dependencies
priors <- priors %>% mutate(flag_sum=flag1+flag2+flag3+flag4+flag5)
priors <- priors %>% filter(flag_sum==0) %>% select(-starts_with("flag"))
priors_all <- bind_rows(priors, priors_all)
i <- nrow(priors_all)
}
priors_all <- priors_all[1:n_samples,]
priors_all <- as.matrix(priors_all) #IMIS package requires matrix or vector
return(priors_all)
}
params <- sample.prior(1000)
View(params)
params <- data.frame(params)
like <- sapply(names(params_calib),
function(x) dunif(params[[x]], params_lb[[x]],
params_ub[[x]]), simplify=F, USE.NAMES=T)
names(params)
params <- data.frame(params)
like <- sapply(names(params),
function(x) dunif(params[[x]], params_lb[[x]],
params_ub[[x]]), simplify=F, USE.NAMES=T)
like <- bind_cols(like)
params <- params %>% mutate(a_p_s=a_p_m, a_r_s=a_r_m, #dependencies
m_ac=params_fixed$m_ac, #use hist bc its larger
p_c=params_fixed$p_c) #prev and hist are same
like <- bind_cols(like)
params <- params %>% mutate(a_p_s=a_p_m, a_r_s=a_r_m, #dependencies
m_ac=params_fixed_hist$m_ac, #use hist bc its larger
p_c=params_fixed_hist$p_c) #prev and hist are same
params <- data.frame(params)
like <- sapply(names(params),
function(x) dunif(params[[x]], params_lb[[x]],
params_ub[[x]]), simplify=F, USE.NAMES=T)
like <- bind_cols(like)
params <- params %>% mutate(a_p_s=a_p_m, a_r_s=a_r_m, #dependencies
m_ac=params_fixed_hist$m_ac, #use hist bc its larger
p_c=params_fixed_hist$p_c) #prev and hist are same
params <- params %>%
mutate(flag1=1*((p_m + p_s + m_ac + c_sp) > 1),
flag2=1*((r_m + a_p_s*p_s + m_ac) > 1),
flag3=1*((r_s + a_p_m*p_m + m_tb + m_ac + c_tx) > 1),
flag4=1*((a_r_s*r_s + a_r_m*r_m + a_m*m_tb + m_ac + a_tx*c_tx) > 1),
flag5=1*((p_c + m_ac) > 1)
)
flags <- params %>%  select(contains("flag"))
flags <- flags*-1 + 1
like <- cbind(like, flags)
like <- rowProds(as.matrix(like))
library(matrixStats)
like <- rowProds(as.matrix(like))
like
cyc_len <- 1/12
calib_out <- function(params_calib, params_fixed, calib_type, t_end, cyc_len, sim_pop) {
p_use <- c(params_calib, params_fixed)
#parameter dependencies
params_depend <- c("a_p_s"=p_use[["a_p_m"]],
"a_r_s"=p_use[["a_r_m"]]
)
p_use <- c(p_use, params_depend)
for(t in 1:t_end) {
curr_pop <- nat_hist_markov(p_use, sim_pop[t,], t)
sim_pop <- bind_rows(sim_pop, curr_pop)
}
if(calib_type=="prev") {
#prevalence survey targets are cross-sectional - no need for cycle length adjustment.
#notifications/deaths need cycle length adjustment (modeled deaths are cumulative so adjust for that too)
outputs <- c("prop_m_all"=(sim_pop[t+1,"tb_m"]+sim_pop[t+1, "tb_ms"])/sum(sim_pop[t, tb_states]),
"prop_s_all"=(sim_pop[t+1,"tb_s"]+sim_pop[t+1, "tb_ms"])/sum(sim_pop[t, tb_states]),
"prop_ms"=sim_pop[t+1,"tb_ms"]/sum(sim_pop[t+1,tb_states]),
"pnr_m_all"=(sim_pop[t+1,"tb_m"]+sim_pop[t+1,"tb_ms"])/
sum((sim_pop[((t+1)-(1/cyc_len)):(t+1),"tb_ms"])*p_use[["c_tx"]]*p_use[["a_tx"]]), #smear-positive divided by smear-positive that get treated
"deaths_tb"=(sim_pop[t+1,"died_tb"]-sim_pop[(t+1)-(1/cyc_len),"died_tb"])/sum(sim_pop[t+1,tb_states]), #incremental tb deaths divided by tb cases
"prop_m_notif"=(sim_pop[t+1, "tb_ms"]*p_use[["c_tx"]]*p_use[["a_tx"]])/
(sim_pop[t+1, "tb_ms"]*p_use[["c_tx"]]*p_use[["a_tx"]] +
sim_pop[t+1, "tb_s"]*p_use[["c_tx"]]) #proportion of notifications that are smear-positive
)
} else if(calib_type=="hist_pos") {
#adjust timing (5 yrs and 10 yrs) for cycle length
dead_5yr=sim_pop[5/cyc_len, "died_tb"] + sim_pop[5/cyc_len, "died_nontb"]
dead_10yr=sim_pop[10/cyc_len, "died_tb"] + sim_pop[10/cyc_len, "died_nontb"]
outputs <- c("tb_ms_dead_5yr"=dead_5yr, "tb_ms_dead_10yr"=dead_10yr)
} else if (calib_type=="hist_neg") {
dead_5yr=sim_pop[5/cyc_len, "died_tb"] + sim_pop[5/cyc_len, "died_nontb"]
dead_10yr=sim_pop[10/cyc_len, "died_tb"] + sim_pop[10/cyc_len, "died_nontb"]
outputs <- c("tb_s_dead_5yr"=dead_5yr, "tb_s_dead_10yr"=dead_10yr)
}
#apply penalties if compartment sizes are > 1 or < 0 or transitions out exceed 1 - add as separate variable in outputs
penalties <- 999999*(sum(curr_pop[2:length(curr_pop)])<0) +
999999*(sum(curr_pop[alive_states])>1.02) +
999999*((p_use$p_m + p_use$p_s + p_use$m_ac + p_use$c_sp) > 1) +
999999*((p_use$r_m + p_use$a_p_s*p_use$p_s + p_use$m_ac) > 1) +
999999*((p_use$r_s + p_use$a_p_m*p_use$p_m + p_use$m_tb + p_use$m_ac + p_use$c_tx) > 1) +
999999*((p_use$a_r_s*p_use$r_s + p_use$a_r_m*p_use$r_m + p_use$a_m*p_use$m_tb + p_use$m_ac + p_use$a_tx*p_use$c_tx) > 1) +
999999*((p_use$p_c + p_use$m_ac) > 1) +
0
if(is.na(penalties)) {
penalties <- 999999*(is.na(sum(curr_pop))) +
999999*((p_use$p_m + p_use$p_s + p_use$m_ac + p_use$c_sp) > 1) +
999999*((p_use$r_m + p_use$a_p_s*p_use$p_s + p_use$m_ac) > 1) +
999999*((p_use$r_s + p_use$a_p_m*p_use$p_m + p_use$m_tb + p_use$m_ac + p_use$c_tx) > 1) +
999999*((p_use$a_r_s*p_use$r_s + p_use$a_r_m*p_use$r_m + p_use$a_m*p_use$m_tb + p_use$m_ac + p_use$a_tx*p_use$c_tx) > 1) +
999999*((p_use$p_c + p_use$m_ac) > 1) +
0
}
out_all <- list("outputs"=outputs, "penalties"=penalties, "sim_pop"=sim_pop)
return(out_all)
}
pull_targets <- function(calib_type, targets_all) {
if(calib_type=="hist_pos") {
targets <- targets_all[c("tb_ms_dead_5yr","tb_ms_dead_10yr")]
names <- c("tb_ms_dead_5yr"="5-Year Mortality (%), Smear+ TB",
"tb_ms_dead_10yr"="10-Year Mortality (%), Smear+ TB")
} else if(calib_type=="hist_neg") {
targets <- targets_all[c("tb_s_dead_5yr","tb_s_dead_10yr")]
names <- c("tb_s_dead_5yr"="5-Year Mortality (%), Smear- TB",
"tb_s_dead_10yr"="10-Year Mortality (%), Smear- TB")
} else if(calib_type=="prev") {
targets <- c(targets_all[1:5], targets_all[10])
names <- c("prop_m_all"="% Cases Smear+",
"prop_s_all"="% Cases Symptomatic",
"prop_ms"="% Cases Smear+ & Symptomatic",
"pnr_m_all"="Smear+ Prevalence:Notifications",
"deaths_tb"="Unreated TB Deaths/1000 cases",
"prop_m_notif"="% Notifications Smear+")
} else {
targets <- NA
print("Error: incorrect calibration type specified")
}
return(list(targets, names))
}
if(is.vector(params)) {
params <- data.frame(t(params))
} else {
params <- data.frame(params)
}
t_end <- 200*12
start_pop <- c("t"=0,
"tb"=1, #smear- symptom- TB
"tb_m"=0, #smear+ symptom- TB
"tb_s"=0, #smear- symptom+ TB
"tb_ms"=0, #smear+ symptom+ TB
"sp_cure"=0, #spontaneously cured
"tx_cure"=0, #cured via diagnosis and treatment
"died_tb"=0, #TB death
"died_nontb"=0 #non-TB death
)
targets <- pull_targets("prev", targets_all)[[1]]
names <- pull_targets("prev", targets_all)[[2]]
names
targets
sim_pop <- data.frame()
sim_pop <- bind_rows(sim_pop, start_pop)
params_use <- params %>% select(names(params_lb))
out_prev <- lapply(1:nrow(params_use), function(x)
calib_out(params_use[x,], params_fixed_prev, "prev",
t_end, cyc_len, sim_pop)$outputs)
source("model_functions.R")
out_prev <- lapply(1:nrow(params_use), function(x)
calib_out(params_use[x,], params_fixed_prev, "prev",
t_end, cyc_len, sim_pop)$outputs)
View(out_prev)
out_prev <- bind_rows(out_prev)
View(out_prev)
calc_like <- function(out, targets_all, mort_samples,
prop_m_notif_smooth, pnr_params, calib_type) {
if(calib_type=="prev") {
#prevalence survey targets proportion of infections by smear/symptom status - we have actual sample size
prop_m_all <- dbinom(round(targets_all[["prop_m_all"]]*356), size=356, prob=out[["prop_m_all"]], log=T)
prop_s_all <- dbinom(round(targets_all[["prop_s_all"]]*359), size=359, prob=out[["prop_s_all"]], log=T)
prop_ms <- dbinom(round(targets_all[["prop_ms"]]*356), size=356, prob=out[["prop_ms"]], log=T)
#prevalence to notification ratio: 0 to inf - gamma fits well (parameters estimated using dampack gamma_params)
pnr_m_all <- dgamma(out[["pnr_m_all"]], shape=pnr_params$pnr_gamma_shape, scale=pnr_params$pnr_gamma_scale, log=T)
#use empirical distribution for the TB mortality target
deaths_tb <- unname(log(mort_samples[as.character(round(out[["deaths_tb"]]*1000))]))
#make likelihood very very small (and decreasing) if > max of all mort samples (min is 0 so no need to do this on low end)
deaths_tb[(is.na(deaths_tb)|deaths_tb==-Inf) & !is.na(out[["deaths_tb"]])] <-
unlist(log(1/abs(round(out[(is.na(deaths_tb)|deaths_tb==-Inf) & !is.na(out[["deaths_tb"]]),
"deaths_tb"]*1000)-max(unname(mort_samples)))/1000000))
#proportion of notifications that are smear-positive - use empirical distribution
prop_m_notif <- unname(log(prop_m_notif_smooth[as.character(round(out[["prop_m_notif"]]*100))]))
log_like_all <- data.frame("prop_m_all"=prop_m_all,
"prop_s_all"=prop_s_all,
"prop_ms"=prop_ms,
"pnr_m_all"=pnr_m_all,
"deaths_tb"=deaths_tb,
"prop_m_notif"=prop_m_notif)
} else if(calib_type=="hist_pos") {
#historical mortality targets - sizes (n) of binomial distributions established to match CIs from meta-regression
tb_ms_dead_5yr <- dbinom(round(targets_all[["tb_ms_dead_5yr"]]*220), size=220, prob=out[["tb_ms_dead_5yr"]], log=T)
tb_ms_dead_10yr <- dbinom(round(targets_all[["tb_ms_dead_10yr"]]*220), size=220, prob=out[["tb_ms_dead_10yr"]], log=T)
log_like_all <- data.frame("tb_ms_dead_5yr"=tb_ms_dead_5yr,
"tb_ms_dead_10yr"=tb_ms_dead_10yr)
} else if(calib_type=="hist_neg") {
#historical mortality targets - sizes (n) of binomial distributions established to match CIs from meta-regression
tb_s_dead_5yr <- dbinom(round(targets_all[["tb_s_dead_5yr"]]*325), size=325, prob=out[["tb_s_dead_5yr"]], log=T)
tb_s_dead_10yr <- dbinom(round(targets_all[["tb_s_dead_10yr"]]*200), size=200, prob=out[["tb_s_dead_10yr"]], log=T)
log_like_all <- data.frame("tb_s_dead_5yr"=tb_s_dead_5yr,
"tb_s_dead_10yr"=tb_s_dead_10yr)
} else {
print("error: incorrect calibration type")
}
log_like <- rowSums(log_like_all)
like <- rowProds(as.matrix(exp(log_like_all)))
like_out <- list("like"=like, "log_like"=log_like)
return(like_out)
}
like_prev <- calc_like(out_prev, targets_all, mort_samples,
prop_m_notif_smooth, pnr_params, "prev")
rm(targets)
rm(names)
View(like_prev)
n_time <- 10/cyc_len
start_pop <- c("t"=0,
"tb"=0, #smear- symptom- TB
"tb_m"=0, #smear+ symptom- TB
"tb_s"=0, #smear- symptom+ TB
"tb_ms"=1, #smear+ symptom+ TB
"sp_cure"=0, #spontaneously cured
"tx_cure"=0, #cured via diagnosis and treatment
"died_tb"=0, #TB death
"died_nontb"=0, #non-TB death
"rel_inf"=0 #relative number of secondary infections generated
)
sim_pop <- data.frame()
sim_pop <- bind_rows(sim_pop, start_pop)
params_use <- params %>% select(-c_tx) #no tx in historical version
View(params_use)
setwd("~/GitHub/tb-natural-history")
#load packages
library(lhs)
library(dplyr)
library(mvtnorm)
library(matrixStats)
#load objects used in calibration (parameter bounds, fixed parameters, and targets/related)
load("calibration_inputs.Rda")
#load model functions and functions used in calibration
source("model_functions.R")
source("calibration_functions.R")
cyc_len <- 1/12 #monthly time step
params <- sample.prior(1000)
prior <- prior(params)
prior
if(is.vector(params)) {
params <- data.frame(t(params))
} else {
params <- data.frame(params)
}
n_time <- 10/cyc_len
start_pop <- c("t"=0,
"tb"=0, #smear- symptom- TB
"tb_m"=0, #smear+ symptom- TB
"tb_s"=0, #smear- symptom+ TB
"tb_ms"=1, #smear+ symptom+ TB
"sp_cure"=0, #spontaneously cured
"tx_cure"=0, #cured via diagnosis and treatment
"died_tb"=0, #TB death
"died_nontb"=0, #non-TB death
"rel_inf"=0 #relative number of secondary infections generated
)
sim_pop <- data.frame()
sim_pop <- bind_rows(sim_pop, start_pop)
params_use <- params %>% select(-c_tx) #no tx in historical version
params_use <- params %>% select(names(params_lb)) %>%
select(-c_tx) #no tx in historical version
out_hist_pos <- lapply(1:nrow(params_use), function(x)
calib_out(params_use[x,], params_fixed_hist, "hist_pos",
t_end, cyc_len, sim_pop)$outputs)
t_end <- 10/cyc_len
out_hist_pos <- lapply(1:nrow(params_use), function(x)
calib_out(params_use[x,], params_fixed_hist, "hist_pos",
t_end, cyc_len, sim_pop)$outputs)
out_hist_pos <- bind_rows(out_hist_pos)
View(out_hist_pos)
like_hist_pos <- calc_like(out_hist_pos, targets_all, mort_samples,
prop_m_notif_smooth, pnr_params, "hist_pos")
View(like_hist_pos)
start_pop <- c("t"=0,
"tb"=0, #smear- symptom- TB
"tb_m"=0, #smear+ symptom- TB
"tb_s"=1, #smear- symptom+ TB
"tb_ms"=0, #smear+ symptom+ TB
"sp_cure"=0, #spontaneously cured
"tx_cure"=0, #cured via diagnosis and treatment
"died_tb"=0, #TB death
"died_nontb"=0, #non-TB death
"rel_inf"=0 #relative number of secondary infections generated
)
sim_pop <- data.frame()
sim_pop <- bind_rows(sim_pop, start_pop)
out_hist_neg <- lapply(1:nrow(params_use), function(x)
calib_out(params_use[x,], params_fixed_hist, "hist_neg",
t_end, cyc_len, sim_pop)$outputs)
out_hist_neg <- bind_rows(out_hist_neg)
like_hist_neg <- calc_like(out_hist_neg, targets_all, mort_samples,
prop_m_notif_smooth, pnr_params, "hist_neg")
t_end <- 200/cyc_len
start_pop <- c("t"=0,
"tb"=1, #smear- symptom- TB
"tb_m"=0, #smear+ symptom- TB
"tb_s"=0, #smear- symptom+ TB
"tb_ms"=0, #smear+ symptom+ TB
"sp_cure"=0, #spontaneously cured
"tx_cure"=0, #cured via diagnosis and treatment
"died_tb"=0, #TB death
"died_nontb"=0 #non-TB death
)
sim_pop <- data.frame()
sim_pop <- bind_rows(sim_pop, start_pop)
params_use <- params %>% select(names(params_lb))
out_prev <- lapply(1:nrow(params_use), function(x)
calib_out(params_use[x,], params_fixed_prev, "prev",
t_end, cyc_len, sim_pop)$outputs)
out_prev <- bind_rows(out_prev)
like_prev <- calc_like(out_prev, targets_all, mort_samples,
prop_m_notif_smooth, pnr_params, "prev")
log_like_all <-  like_prev$log_like + like_hist_pos$log_like + like_hist_neg$log_like
like <- exp(log_like_all)
like[is.na(like)] <- 0
out <- list("out_prev"=out_prev,
"out_hist_pos"=out_hist_pos,
"out_hist_neg"=out_hist_neg,
"like_prev"=like_prev$like,
"like_hist_pos"=like_hist_pos$like,
"like_hist_neg"=like_hist_neg$like,
"log_like_all"=log_like_all,
"like"=like)
setwd("~/GitHub/tb-natural-history")
#load packages
library(lhs)
library(dplyr)
library(mvtnorm)
library(matrixStats)
#load objects used in calibration (parameter bounds, fixed parameters, and targets/related)
load("calibration_inputs.Rda")
#load model functions and functions used in calibration
source("model_functions.R")
source("calibration_functions.R")
cyc_len <- 1/12 #monthly time step
chain <- 1 #running 50 separate IMIS chains - which one is this?
D <- 0 #don't optimize first
B <- 100
B.re <- 1000
number_k <- 5
post <- IMIS_copy(B, B.re, number_k, D)
post_params <- bind_cols(data.frame(post$resample), post$out)
View(post_params)
params_opt <- post$center
stats_out <- post$stat
View(stats_out)
View(params_opt)
#script to test the Markov model
setwd("~/GitHub/tb-natural-history")
library(tidyverse)
#load model functions and test model parameters (posterior means from main analysis)
source("R/model_functions.R")
load("data/params_test.Rda")
t_end <- 240 #run for 20 years (240 months)
inflows <- 1 #run with inflows on (deaths re-enter the model as smear-negative subclinical TB)
params <- c(params, "inflows"=inflows)
#declare starting compartment sizes
start_pop <- c("t"=0,
"tb"=1, #smear- symptom- TB
"tb_m"=0, #smear+ symptom- TB
"tb_s"=0, #smear- symptom+ TB
"tb_ms"=0, #smear+ symptom+ TB
"sp_cure"=0, #spontaneously cured
"tx_cure"=0, #cured via diagnosis and treatment
"died_tb"=0, #TB death
"died_nontb"=0 #non-TB death
)
#run Markov model
sim_pop <- data.frame()
sim_pop <- bind_rows(sim_pop, start_pop)
#run for t timesteps
verbose <- 1 #show model progress
for(t in 1:t_end) {
if(verbose==1) {
cat('\r', paste(round(t/t_end * 100), "% done", sep = " ")) # display the progress of the simulation
}
curr_pop <- nat_hist_markov(params, sim_pop[t,], t)
sim_pop <- bind_rows(sim_pop, curr_pop)
}
#clean output
sim_pop_long <- process_output(sim_pop)
#graph Markov trace curves
ggplot(sim_pop_long %>% filter(outcome %in% alive_states),
aes(x=t, y=value_scale*100, color=name)) + geom_line() +
labs(x="Time", y="Percent in State", color="States") +
theme_bw() + theme(panel.grid=element_blank())
#script to test the microsimulation version of the model
setwd("~/GitHub/tb-natural-history")
library(tidyverse)
#load model functions and test parameters (posterior means from main analysis)
source("R/model_functions.R")
load("data/params_test.Rda")
t_end <- 240 #run for 20 years (240 months)
inflows <- 1 #run with inflows on (deaths re-enter the model as smear-negative subclinical TB)
params <- c(params, "inflows"=inflows)
n <- 10000 #run with 1000 individuals
#columns in "sim_ind" are timesteps, rows are individuals
#cells in "sim_ind" indicate the state an individual is in at each timestep:
#1=tb (smear- symptom-)
#2=tb_m (smear+ symptom-)
#3=tb_s (smear- symptom+)
#4=tb_ms (smear+ symptom+)
#5=sp_cure (spontaneously cured)
#6=tx_cure (cured w/ diagnosis & treatment)
#7=died_tb (TB death)
#8=died_nontb (non-TB death)
#VERSION 1: everyone starts out smear-negative, run to steady state
rands <- micro_sample(params, n, t_end) #sample random numbers up front
sim_ind <- data.frame("0"=rep(1, n))
verbose <- 1 #show model progress
for(t in 1:t_end) {
if(verbose==1) {
cat('\r', paste(round(t/t_end * 100), "% done", sep = " ")) # display the progress of the simulation
}
curr_ind <- nat_hist_micro(sim_ind[,t], rands[(n*(t-1)+1):(n*t),], params)
sim_ind <- cbind(sim_ind, curr_ind)
}
names(sim_ind) <- 0:t_end
#process output
sim_ind_long <- data.frame(sapply(1:length(states), function(x) colSums(sim_ind==x))) #convert to dataframe of counts by state over time. rowSums if transposed
names(sim_ind_long) <- states
sim_ind_long <- cbind("t"=0:t_end, sim_ind_long/n) #convert to proportions
if(params$inflows==1) { #replace with cumulatives since deaths are reseeded if inflows turned on
sim_ind_long$died_tb <- cumsum(sim_ind_long$died_tb)
sim_ind_long$died_nontb <- cumsum(sim_ind_long$died_nontb)
}
sim_ind_long <- process_output(sim_ind_long)
#graph Markov trace curves
ggplot(sim_ind_long %>% filter(outcome %in% alive_states),
aes(x=t, y=value_scale*100, color=name)) + geom_line() +
labs(x="Time", y="Percent in State", color="States") +
theme_bw() + theme(panel.grid=element_blank())
#VERSION 2: simulate cohort w/ Philippines TB prevalence (turn off inflows)
props <- c(0.51, 0.20, 0.12, 0.17)
params[["inflows"]] <- 0
sim_ind <- data.frame("0"=c(rep(1, round(props[[1]]*n)),
rep(2, round(props[[2]]*n)),
rep(3, round(props[[3]]*n)),
rep(4, round(props[[4]]*n))))
verbose <- 1 #show model progress
for(t in 1:t_end) {
if(verbose==1) {
cat('\r', paste(round(t/t_end * 100), "% done", sep = " ")) # display the progress of the simulation
}
curr_ind <- nat_hist_micro(sim_ind[,t], rands[(n*(t-1)+1):(n*t),], params)
sim_ind <- cbind(sim_ind, curr_ind)
}
names(sim_ind) <- 0:t_end
#process output
sim_ind_long <- data.frame(sapply(1:length(states), function(x) colSums(sim_ind==x))) #convert to dataframe of counts by state over time. rowSums if transposed
names(sim_ind_long) <- states
sim_ind_long <- cbind("t"=0:t_end, sim_ind_long/n) #convert to proportions
if(params$inflows==1) { #replace with cumulatives since deaths are reseeded if inflows turned on
sim_ind_long$died_tb <- cumsum(sim_ind_long$died_tb)
sim_ind_long$died_nontb <- cumsum(sim_ind_long$died_nontb)
}
sim_ind_long <- process_output(sim_ind_long)
#graph Markov trace curves
ggplot(sim_ind_long %>% filter(outcome %in% alive_states),
aes(x=t, y=value_scale*100, color=name)) + geom_line() +
labs(x="Time", y="Percent in State", color="States") +
theme_bw() + theme(panel.grid=element_blank())
#calculate average duration with TB by starting state
durations <- sim_ind %>% mutate_all(~if_else(. %in% 1:4, 1 ,0))
durations <- rowSums(durations)
durations <- data.frame("start_pop"=sim_ind[,"0"],
"duration"=durations)
durations %>% group_by(start_pop) %>%
summarise(duration=mean(duration))
setwd("~/GitHub/tb-natural-history")
#load packages
library(lhs)
library(dplyr)
library(mvtnorm)
library(matrixStats)
#load objects used in calibration (parameter bounds, fixed parameters, and targets/related)
load("data/calibration_inputs.Rda")
#load model functions and functions used in calibration
source("R/model_functions.R")
source("R/calibration_functions.R")
cyc_len <- 1/12 #monthly time step
chain <- 1 #running 50 separate IMIS chains - which one is this?
path_out <- "output/"
#arguments needed for IMIS function - this will take about 3 days to run
B <- 10000 #10,000 samples per IMIS round (100,000 initially)
B.re <- 1000 #1000 samples of the posterior
number_k <- 12 #run 10 rounds of IMIS
D <- 0 #don't optimize first
#test using smaller number of samples and rounds (this takes about 30 minutes)
B <- 100
B.re <- 1000
number_k <- 5
D <- 0 #don't optimize first
